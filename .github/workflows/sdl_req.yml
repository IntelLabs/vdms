# Uses docker/check-in/Dockerfile.base
# Dockerfile.base -> Same as docker/base/Dockerfile but builds VDMS with local changes instead of external repo
name: SDL Requirements using Docker Image

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master and develop branch
# on:
#   pull_request:
#     types: [ opened, edited, synchronize, reopened ]
#     branches:
#       - develop
#       - master
on:
  push:
    branches:
      - develop

# Environment variables
env:
  ARTIFACT_DIR: SDL_artifacts
  DOCKER_ARTIFACT_DIR: Docker_artifacts
  NEW_BASE_DOCKERFILE: docker/check-in/Dockerfile.base
  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN}}
  SNYK_API: ${{ secrets.SNYK_API}}
  # CHECKOUT_REF: ${{ github.event.pull_request.head.sha }}
  FACELESS_USERNAME: ${{ secrets.FACELESS_NAME}}
  COVERITY_DOCKERFILE: docker/check-in/Dockerfile.coverity
  FACELESS_AUTHKEY: ${{ secrets.FACELESS_AUTHKEY}}
  COVERITYSTREAM: ${{ secrets.COVERITYSTREAM}}
  COVERITYSERVER: ${{ secrets.COVERITYSERVER }}

jobs:
  # RUN HADOLINT & BANDIT; NO DOCKER BUILD NEEDED
  Hadolint:
    name: Haskell Dockerfile Linter
    runs-on:
      group: intellabs-generic-runners
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        # with:
        #   ref: ${{ env.CHECKOUT_REF }}
      - run: mkdir -p ${{ env.ARTIFACT_DIR }}
      # - name: Run Hadolint Docker Container (unstable)
      #   uses: intel-innersource/frameworks.devops.github.actions.hadolint@main
      #   with:
      #     dockerfile: ${{ env.NEW_BASE_DOCKERFILE}}
      #     report_path: ${{ env.ARTIFACT_DIR }}
      - name: Run Hadolint Docker Container
        id: get_hadolint
        run: |
          set -x
          docker run --rm -i hadolint/hadolint:latest < ${{ env.NEW_BASE_DOCKERFILE}} 2>&1 | tee ${{ env.ARTIFACT_DIR }}/hadolint_output.txt
          output=$(cat ${{ env.ARTIFACT_DIR }}/hadolint_output.txt | awk '{print $2}' | sort -u)

          echo "hadolint_output<<EOF" >> $GITHUB_ENV
          echo "$output" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Print Hadolint Results in Job Summary
        shell: bash
        run: |
          set -x
          echo "### Hadolint Returned Rule Codes" > $GITHUB_STEP_SUMMARY
          echo "${{ env.hadolint_output }}" >> $GITHUB_STEP_SUMMARY
      - name: Upload Hadolint Artifact
        uses: actions/upload-artifact@v3
        with:
          name: sdl-artifacts
          path: ${{ env.ARTIFACT_DIR }}/hadolint_output.txt
      - name: Cleanup
        if: always()
        run: |
          rm /tmp/tmp-* || true
          rm -rf ${{ env.ARTIFACT_DIR }}|| true

  Bandit:
    name: Run Bandit
    runs-on: gasp
    container:
      image: cache-registry.caas.intel.com/cache/library/python:3.8-slim
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        # with:
        #   ref: ${{ env.CHECKOUT_REF }}
      - name: Run Bandit
        id: bandit
        run: |
          pip install bandit
          mkdir -p ${{ env.ARTIFACT_DIR }}
          bandit ./ -r -c .github/workflows/ipas_default.config -f csv -o ${{ env.ARTIFACT_DIR }}/bandit_report.csv
      - name: Upload Bandit Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: Bandit Report
          path: ${{ env.ARTIFACT_DIR }}
      - name: Cleanup
        # cf. https://github.com/actions/upload-artifact/issues/256
        if: always()
        run: rm /tmp/tmp-* ${{ env.ARTIFACT_DIR }} ${GITHUB_WORKSPACE}/* || true

  # BUILD LATEST CODE AS DOCKER IMAGE; USED WITH SNYK, CIS, & BDBA JOBS
  BuildLatest:
    # This job builds docker container for later use
    name: Build Latest Docker
    runs-on:
      group: intellabs-generic-runners
      labels: vdms-check-in
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        with:
          submodules: true
          # ref: ${{ env.CHECKOUT_REF }}
      - run: mkdir -p ${{ env.DOCKER_ARTIFACT_DIR }}
      - name: Build Docker Container
        run: |
          docker build --rm -f ${{ env.NEW_BASE_DOCKERFILE}} -t vdms:latest .
          docker save -o ${{ env.DOCKER_ARTIFACT_DIR }}/vdms_latest.tar vdms:latest
      - name: Upload Docker Image Artifact
        if: success()
        uses: actions/upload-artifact@v3
        with:
          name: vdms_latest.tar
          path: ${{ env.DOCKER_ARTIFACT_DIR }}/vdms_latest.tar
          retention-days: 1
      - name: Cleanup
        if: always()
        run: |
          rm /tmp/tmp-* ${{ env.DOCKER_ARTIFACT_DIR }} ${GITHUB_WORKSPACE}/* || true
          docker rmi $(docker images | grep '<none>' | awk '{print $3}') || true

  BDBA:
    runs-on: gasp
    name: BDBA
    needs: BuildLatest
    container:
      image: cache-registry.caas.intel.com/cache/library/python:3.8-slim
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v3
        with:
          name: vdms_latest.tar
          path: ${{ env.DOCKER_ARTIFACT_DIR }}
      - name: Run BDBA
        id: bdba
        continue-on-error: true
        env:
          BDBA_TOKEN: "${{ secrets.BDBA_TOKEN }}"
        uses: intel-innersource/frameworks.actions.bdba@main
        with:
          bdba_group: '90'  # Change this to your group
          bdba_binary: '${{ env.DOCKER_ARTIFACT_DIR }}/vdms_latest.tar'
      - name: BDBA Failure Check
        if: failure()
        run: echo "Check BDBA Server(https://bdba001.icloud.intel.com/) for binary vdms_latest.tar"
      - run: rm -rf ${{ env.DOCKER_ARTIFACT_DIR }}

  Snyk:
    # This job runs Snyk for Vulnerabilities and extract list of dependencies
    name: Snyk Scan for Vulnerabilities
    needs: BuildLatest
    runs-on:
      group: intellabs-generic-runners
      labels: vdms-check-in
    container:
      image: snyk/snyk:docker
      env:
        SNYK_TOKEN: ${{ env.SNYK_TOKEN}}
        SNYK_API: ${{ env.SNYK_API}}
        SNYK_DISABLE_ANALYTICS: 1
        PROJ_NAME: EVS_vdms
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        with:
          submodules: true
          # ref: ${{ env.CHECKOUT_REF }}
      - run: mkdir -p ${{ env.DOCKER_ARTIFACT_DIR }} ${{ env.ARTIFACT_DIR }}
      - name: Download docker image
        uses: actions/download-artifact@v3
        with:
          name: vdms_latest.tar
          path: ${{ env.DOCKER_ARTIFACT_DIR }}
      - name: Load Docker Image
        run: docker load -i ${{ env.DOCKER_ARTIFACT_DIR }}/vdms_latest.tar
      - name: Snyk Docker Image Scan (Test & Monitor)
        run: |
          NO_PROXY="" HTTP_PROXY="" HTTPS_PROXY="" no_proxy="" http_proxy="" https_proxy="" snyk container test -d vdms:latest --file=${{ env.NEW_BASE_DOCKERFILE}} \
            --exclude-base-image-vulns --project-name="$PROJ_NAME" > ${{ env.ARTIFACT_DIR }}/CT36_docker_snyk_scan.log  || true

          # Results
          output_checks=$(cat ${{ env.ARTIFACT_DIR }}/CT36_docker_snyk_scan.log | grep "Tested ")
          echo "snyk_image_results<<EOF" >> $GITHUB_ENV
          echo "$output_checks" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Snyk Python Scan (Test & Monitor)
        run: |
          docker run --rm -i vdms:latest bash -c "pip3 freeze -l" | tee ${PWD}/requirements.txt
          docker run --rm -i --env SNYK_TOKEN=${{ env.SNYK_TOKEN}} \
            --env SNYK_API=${{ env.SNYK_API}} --env SNYK_DISABLE_ANALYTICS=1 \
            --env COMMAND="pip install -r /app/requirements.txt --proxy $HTTP_PROXY" \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${PWD}:/app/ \
            snyk/snyk:python-3.8 snyk test -d --file=/app/requirements.txt --package-manager=pip --exclude-base-image-vulns \
              --project-name="$PROJ_NAME-python" > ${PWD}/${{ env.ARTIFACT_DIR }}/CT36_docker_snyk_python_scan.log  || true

          # Results
          output_checks=$(cat ${PWD}/${{ env.ARTIFACT_DIR }}/CT36_docker_snyk_python_scan.log | grep "Tested ")
          echo "snyk_python_results<<EOF" >> $GITHUB_ENV
          echo "$output_checks" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Upload SNYK & Dependency Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: SNYK Reports
          path: ${{ env.ARTIFACT_DIR }}
      - name: Print SNYK Results in Job Summary
        run: |
          echo "### SNYK Results" > $GITHUB_STEP_SUMMARY
          echo "Docker Scan :point_right:${{ env.snyk_image_results }}" >> $GITHUB_STEP_SUMMARY
          echo "Python 3.8 Scan :point_right:${{ env.snyk_python_results }}" >> $GITHUB_STEP_SUMMARY
      - name: Cleanup
        if: always()
        run: |
          docker stop snyk_py && docker rm snyk_py ${GITHUB_WORKSPACE}/*|| true
          rm /tmp/tmp-* || true
          rm -rf ${{ env.ARTIFACT_DIR }} ${{ env.DOCKER_ARTIFACT_DIR }} || true

  CIS:
    # This job runs CIS Docker Benchmark
    name: CIS Docker Benchmark
    needs: BuildLatest
    runs-on:
      group: intellabs-generic-runners
      labels: vdms-check-in
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        with:
          submodules: true
          # ref: ${{ env.CHECKOUT_REF }}
      - name: Download Docker Image
        uses: actions/download-artifact@v3
        with:
          name: vdms_latest.tar
          path: ${{ env.DOCKER_ARTIFACT_DIR }}
      - name: Load Docker Image
        run: |
          docker load -i ${{ env.DOCKER_ARTIFACT_DIR }}/vdms_latest.tar
      - name: Run Benchmark
        id: run_CIS
        run: |
          set -x
          mkdir -p ${{ env.ARTIFACT_DIR }}
          git clone https://github.com/docker/docker-bench-security.git
          cd docker-bench-security

          docker container run --net=host -d \
            --security-opt=no-new-privileges \
            --health-cmd='cd /vdms/build && ./vdms || exit 1' \
            --restart on-failure:5 \
            --name vdms_test-CIS vdms:latest

          mkdir -p ${{ env.ARTIFACT_DIR }}
          sh docker-bench-security.sh -c container_runtime -i vdms_test-CIS -l CT249_CIS_report.txt
          mv CT249_CIS_report.txt  ${{ env.ARTIFACT_DIR }}/CT249_CIS_report.txt

          output_checks=$(cat ${{ env.ARTIFACT_DIR }}/CT249_CIS_report.txt | grep "Checks:" | sed 's/^.*Checks/Checks/')
          output_score=$(cat ${{ env.ARTIFACT_DIR }}/CT249_CIS_report.txt | grep "Score:" | sed 's/^.*Score/Score/')

          echo "cis_output_checks<<EOF" >> $GITHUB_ENV
          echo "$output_checks" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "cis_output_score<<EOF" >> $GITHUB_ENV
          echo "$output_score" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Upload CIS Artifact
        uses: actions/upload-artifact@v3
        with:
          name: CIS Reports
          path: ${{ env.ARTIFACT_DIR }}/CT249_CIS_report.txt
      - name: Print CIS Results in Job Summary
        shell: bash
        run: |
          echo "### CIS Docker Results" > $GITHUB_STEP_SUMMARY
          echo "${{ env.cis_output_checks }}" >> $GITHUB_STEP_SUMMARY
          echo "${{ env.cis_output_score }}" >> $GITHUB_STEP_SUMMARY
      - name: Cleanup
        # cf. https://github.com/actions/upload-artifact/issues/256
        if: always()
        run: |
          rm /tmp/tmp-* ${{ env.DOCKER_ARTIFACT_DIR }} ${{ env.ARTIFACT_DIR }} ${GITHUB_WORKSPACE}/* || true
          docker stop vdms_test-CIS && docker rm vdms_test-CIS
          docker rmi $(docker images | grep '<none>' | awk '{print $3}') || true

  # BUILD LATEST CODE WITH COVERITY AS DOCKER IMAGE
  Coverity:
    name: Run Coverity
    runs-on:
      group: intellabs-generic-runners
      labels: vdms-check-in
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v3
        with:
          submodules: true
          # ref: ${{ env.CHECKOUT_REF }}
      - name: Build Docker Container with Coverity
        run: |
          cp ${{ env.NEW_BASE_DOCKERFILE}} ${{ env.COVERITY_DOCKERFILE}}
          sed -i -e 's|CMD \["/start.sh"]|RUN mkdir /coverity \&\& cd /coverity \&\& \\|g' ${{ env.COVERITY_DOCKERFILE}}
          echo "    curl -L -o cov-analysis-linux64-2022.3.1.sh  https://ubit-artifactory-or.intel.com/artifactory/coverity-or-local/Enterprise/cov-analysis-linux64-2022.3.1.sh && chmod +x cov-analysis-linux64-2022.3.1.sh && \\"  >> ${{ env.COVERITY_DOCKERFILE}}
          echo "    curl -L -o license.dat https://ubit-artifactory-or.intel.com/artifactory/coverity-or-local/Enterprise/license.dat && \\"  >> ${{ env.COVERITY_DOCKERFILE}}
          echo "    ./cov-analysis-linux64-2022.3.1.sh -q --installation.dir=/opt/coverity/analysis/ \\
            --license.agreement=agree --license.region=0 --license.type.choice=0 \\
            --license.cov.path=/coverity/license.dat --component.sdk=false --component.skip.documentation=true"  >> ${{ env.COVERITY_DOCKERFILE}}
          echo "ENV PATH /opt/coverity/analysis/bin:$PATH" >> ${{ env.COVERITY_DOCKERFILE}}
          echo 'CMD ["/start.sh"]' >> ${{ env.COVERITY_DOCKERFILE}}
          docker build --rm -f ${{ env.COVERITY_DOCKERFILE}} -t vdms:coverity .
      - name: Run Coverity with GCC
        env:
            DOCKER_PROXY_RUN_ARGS: "--env HTTPS_PROXY=$HTTPS_PROXY \
                    --env https_proxy=$https_proxy \
                    --env HTTP_PROXY=$HTTP_PROXY \
                    --env http_proxy=$http_proxy \
                    --env NO_PROXY=${{ secrets.NO_PROXY }} \
                    --env no_proxy=${{ secrets.NO_PROXY }}"
        run: |
          docker run ${{ env.DOCKER_PROXY_RUN_ARGS }} -d --rm --name vdms_test-Coverity \
            --env FACELESS_USERNAME=${{ env.FACELESS_USERNAME}} \
            --env FACELESS_AUTHKEY="${{ env.FACELESS_AUTHKEY}}" \
            --env COVERITYSERVER=${{ env.COVERITYSERVER}} \
            --env COVERITYSTREAM=${{ env.COVERITYSTREAM }} vdms:coverity

          # Configure
          docker exec -w /vdms/build vdms_test-Coverity bash -c "rm -rf * && cov-configure -gcc && cov-configure --compiler c++ --comptype g++ --template"

          # Build
          docker exec -w /vdms/build vdms_test-Coverity bash -c "mkdir -p /coverity-results && cmake .. && cov-build --dir /coverity-results make"

          # Analyze
          docker exec vdms_test-Coverity bash -c "cov-analyze --dir /coverity-results --concurrency --security --rule --enable-constraint-fpp --enable-fnptr --enable-virtual"

          # Commit
          docker exec vdms_test-Coverity bash -c "cov-commit-defects --dir /coverity-results --stream ${COVERITYSTREAM} --url ${COVERITYSERVER} --user ${FACELESS_USERNAME} --password ${FACELESS_AUTHKEY} --debug"
          docker stop vdms_test-Coverity

      - name: Cleanup
        # cf. https://github.com/actions/upload-artifact/issues/256
        if: always()
        run: |
          docker rmi $(docker images | grep '<none>' | awk '{print $3}') || true
          rm -rf /tmp/tmp-* coverity-results ${GITHUB_WORKSPACE}/* || true

