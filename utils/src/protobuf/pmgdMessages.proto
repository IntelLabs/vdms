syntax = "proto3";

package pmgd.protobufs;

message Property
{
    // These prop values need to keep matching the PMGD counterparts.
    enum PropertyType{
        ErrorType    = 0x00;
        NoValueType  = 0x01;
        BooleanType  = 0x02;
        IntegerType  = 0x03;
        StringType   = 0x04;
        FloatType    = 0x05;
        TimeType     = 0x06;
        BlobType     = 0x07;
    }

    PropertyType type = 1;
    string key  = 2;

    bool bool_value = 3;
    int64 int_value = 4;
    string string_value = 5;
    double float_value = 6;
    string time_value = 7;
    bytes blob_value = 8;
}

message Node {
    string tag = 1;
    uint64 id  = 2;  // this will local to the client
    repeated Property properties = 3;
}

message Edge {
    uint64 src = 1; //this will local to the client
    uint64 dst = 2; //this will local to the client
    string tag = 3;
    repeated Property properties = 4;
}

message AddNode
{
    int64 identifier = 1;
    // We want to be able to query and check if this node
    // exists and add only if it doesn't. So if query_node
    // is not set, then we add a node blindly or if query
    // doesn't return a matching node, then add.
    // Assumes unique match else returns an error if multiple
    // nodes found.
    Node node = 2;
    QueryNode query_node = 3;
}

message AddEdge
{
    int64 identifier = 1;
    Edge edge = 2;
}

message PropertyPredicate
{
    // These op values need to keep matching the PMGD counterparts.
    enum Op {
        DontCare = 0x0;
        Eq = 0x1;
        Ne = 0x2;
        Gt = 0x3;
        Ge = 0x4;
        Lt = 0x5;
        Le = 0x6;
        GeLe = 0x7;
        GeLt = 0x8;
        GtLe = 0x9;
        GtLt = 0xa;
    }

    oneof key_oneof {
        // Specify either string key name
        string key = 1;
        // or integer equivalent. Integer is given preference.
        uint32 keyid = 2;
    }

    Op op = 3;
    Property v1 = 4;

    // v2 is of course not required for all the operations above.
    Property v2 = 5;
}

// Indicate what to do with the responses.
enum ResponseType {
    List = 0;
    Count = 1;
    Sum = 2;
    Average = 3;
    NodeID = 4;
    EdgeID = 5;
    // TODO Until there is a reusable iterator, indicate that a
    // query was cached and so no result type was returned.
    Cached = 6;
}

// Indicate whether to And or Or the property predicates specified
// below.
enum PredicateOp {
    And = 0;
    Or = 1;
}

message QueryNode
{
    int64 identifier = 1;

    oneof tag_oneof {
        // Apply to nodes with specific tag using either the int
        uint32 tagid = 2;
        //or string version of the tag.
        string tag = 3;
    }

    // Specify search conditions and whether to OR or AND them
    PredicateOp p_op = 4;
    repeated PropertyPredicate predicates = 5;

    // Specify what to do with the responses. If the option is
    // list, the response properties will indicate list of what
    // properties.
    ResponseType r_type = 6;

    // User could request multiple properties.
    // This is populated only if the r_type is List
    // TODO Change to keyids later. Oneof doesn't work with
    // repeated properties
    repeated string response_keys = 7;

    // Indicate whether we should make sure there was only one value
    // that matched the constraints.
    bool unique = 8;
}

message QueryNeighbor
{
    // Need to match those in PMGD!
    enum EdgeDirection {
        Any = 0;
        Outgoing = 1;
        Incoming = 2;
    }

    oneof link_oneof {
        // First need to find a start node for neighbor search using
        // typical querying.
        QueryNode query_start_node = 1;

        // In case an identifier is specified, provide the value of ref.
        int64 start_identifier = 2;
    }

    // Then need a way to find which neighbors to look at.
    // Use edge direction, and edge tags to specify which neighbors
    // to look at.
    // TODO it will be good if we could specify some property predicates
    // on these edges too! But PMGD needs to support those calls first.
    // TODO I think the neighbor calls can accept a vector of edge tag
    // and direction for more than 1 hop neighbor search. That is not
    // supported with this. Will need a repeated structure.
    // TODO Need hope count
    oneof edgetag_oneof {
        // Apply to nodes with specific tag using either the int
        uint32 e_tagid = 4;
        //or string version of the tag.
        string e_tag = 5;
    }
    EdgeDirection dir = 7;

    // Now specify constraints for the neighbors
    oneof neighbortag_oneof {
        // Apply to nodes with specific tag using either the int
        uint32 n_tagid = 9;
        //or string version of the tag.
        string n_tag = 10;
    }
    // Specify search conditions and whether to OR or AND them
    PredicateOp p_op = 12;
    repeated PropertyPredicate predicates = 13;

    // Indicate whether you want PMGD to check if all neighbors
    // are unique. Does carry a performance penalty to do that
    // in cases where it is known that neighbors are unique.
    bool unique = 14;

    // Specify what to do with the responses. If the option is
    // list, the response properties will indicate list of what
    // properties.
    ResponseType r_type = 16;

    // User could request multiple properties.
    // This is populated only if the r_type is List
    // TODO Change to keyids later. Oneof doesn't work with
    // repeated properties
    repeated string response_keys = 18;
}


message Command
{
    enum CommandId {
        TxBegin      = 0x0;
        TxCommit     = 0x1;
        TxAbort      = 0x2;

        AddNode   = 0x21;
        AddEdge   = 0x22;

        QueryNode = 0x30;
        QueryNeighbor = 0x32;
    }

    // TODO Might need a transaction object here or maybe just another variable
    // to indicate read write etc
    uint64    tx_id  = 1;

    // We will switch over this value
    CommandId cmd_id = 2;
    // Certain queries could generate multiple PMGD
    // commands but their responses should be grouped
    // together. So add a variable to help handle that.
    // This will be copied to the CommandResponse variable.
    uint32 cmd_grp_id = 3;

    //Since all fields are optional,
    //we define all cmds type here.
    AddNode add_node    = 10;
    AddEdge add_edge    = 11;
    QueryNode query_node = 13;
    QueryNeighbor query_neighbor = 15;
}

message PropertyList
{
    repeated Property values = 1;
}

message CommandResponse
{
    enum ErrorCode {
        Success = 0;
        Abort   = 1;
        Error   = 2;
        Exception = 3;
        Empty   = 4;  // For an empty iterator.
        Exists  = 5;  // If you were looking for something and it is found.
        NotUnique  = 6;  // If you were looking for something and it is not unique.
    }

    // We will switch over this value
    ErrorCode error_code = 1;
    string error_msg = 2;

    // Certain queries could generate multiple PMGD
    // commands but their responses should be grouped
    // together. So add a variable to help handle that.
    // This is copied from the Command variable.
    uint32 cmd_grp_id = 3;

    // In order to help figure how to parse response, re-include
    // what we had expected
    ResponseType r_type = 4;

    // If the query asked for sum/average/count.
    // Average is always float. Sum depends on the type of values
    // being summed. Count is always an int value.
    // If the query added a node or edge, this would contain the
    // global node id or the edge id of the last edge added (there
    // could be multiple in case the source or destination nodes
    // come from a query.
    // In case a list was requested, store the count of matching
    // nodes/edges here.
    oneof op_oneof {
        uint64 op_int_value = 5;
        double op_float_value = 6;
    }
    // Even though this map should be in the oneof, can't put
    // it there since it is not allowed. So now we use the count
    // in oneof to store how many nodes/edges matched.
    // For the query, multiple nodes could have met the condition
    // and therefore there can be a list per property key.
    map<string,PropertyList> prop_values = 7;
}
